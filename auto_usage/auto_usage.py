import argparse
import os
import re
import shutil
import subprocess
import sys
from enum import Enum

from . import prog_name, __version__


class State(Enum):
    FINDING = 0
    FOUND = 1
    END = 2
    NOTFOUND = 3


class StateMachine:
    def __init__(self):
        self.state = State.FINDING

    def parse(self, line=""):
        methname = f"{self.state.name.lower()}_state"
        meth = getattr(self, methname)
        if meth is None:
            raise RuntimeError(f"No method: {methname}")

        return meth(line)

    def finding_state(self, line):
        raise NotImplemented

    def found_state(self, line):
        raise NotImplemented

    def end_state(self, line):
        raise NotImplemented

    def notfound_state(self, line):
        raise NotImplemented


class CliUsageParser(StateMachine):
    pat_usage = re.compile(r"^[uU]sage: ")

    def __init__(self):
        super().__init__()
        self._result = []

    def finding_state(self, line):
        if self.pat_usage.match(line):
            self.state = State.FOUND
            self._result.append(line)

    def found_state(self, line):
        self._result.append(line)

    def end_state(self, line):
        pass

    def notfound_state(self, line):
        pass

    @property
    def result(self):
        return "\n".join(self._result)


class CliCmdParser(StateMachine):
    pat_metavar = re.compile(r"^[cC]ommands:\s*$")
    pat_cmd = re.compile(r"^\s*([a-z]+)\s*")

    def __init__(self):
        super().__init__()
        self.cmds = []

    def finding_state(self, line):
        if self.pat_metavar.match(line):
            self.state = State.FOUND

    def found_state(self, line):
        r = self.pat_cmd.search(line)
        if r:
            self.cmds.append(r.group(1))

    def end_state(self, line):
        pass

    def notfound_state(self, line):
        pass


def parse_prog_cli(cli):
    usage = subprocess.run(cli, stdout=subprocess.PIPE).stdout.decode("utf-8")
    cli_usage_parser = CliUsageParser()
    cli_cmd_parser = CliCmdParser()
    for line in usage.split("\n"):
        cli_usage_parser.parse(line)
        cli_cmd_parser.parse(line)
    return cli_usage_parser.result, cli_cmd_parser.cmds


def get_md_usage(query_cmd) -> str:
    usage, cmds = parse_prog_cli(query_cmd + ["--help"])

    s = [f"## Usage\n\n```\n{usage}\n```\n"]
    for cmd in cmds:
        cli = query_cmd + [cmd, "--help"]
        cmd_usage, _ = parse_prog_cli(cli)
        s.append(f"### subcommand: {cmd}\n\n```\n{cmd_usage}\n```\n")

    return "".join(s)


NOTE = "> Note: This usage is auto-generated by [zhangxianbing/auto-usage](https://github.com/zhangxianbing/auto-usage)."


class ReadmeEditor(StateMachine):
    pat_usage = re.compile(r"^## Usage\n?$")
    pat_next_title = re.compile(r"^## [a-zA-Z_-]+\n?$")

    def __init__(self, readme, new_usage):
        super().__init__()

        self.readme = readme
        self.old_readme = f"{readme}.old"
        shutil.copy(self.readme, self.old_readme)

        self.new_usage = new_usage

    def __enter__(self):
        self.infile = open(self.old_readme)
        self.outfile = open(self.readme, "w")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.infile:
            self.infile.close()
        if self.outfile:
            self.outfile.close()
        os.remove(self.old_readme)

    def edit(self):
        for line in self.infile:
            self.parse(line)
        if self.state == State.FINDING:
            self.state = State.NOTFOUND
            self.parse()

        self.outfile.write(f"\n{NOTE}\n")

    def finding_state(self, line):
        if self.pat_usage.match(line):
            self.state = State.FOUND
            self.outfile.write(self.new_usage)
        else:
            self.outfile.write(line)

    def found_state(self, line):
        if self.pat_next_title.match(line):
            self.state = State.END
            self.outfile.write(f"\n{line}")

    def end_state(self, line):
        self.outfile.write(line)

    def notfound_state(self, line):
        self.outfile.write(self.new_usage)


def quickstart(args):
    detail = """Please follow the following steps and input according to prompt...

$ pip install -U cookiecutter

$ cookiecutter git@github.com:zhangxianbing/cookiecutter-pypackage.git

$ cd ${your_project}

$ auto-usage
"""
    print(detail)


def main():
    root = os.getcwd()
    sys.path.insert(1, root)
    prog_slug = os.path.basename(root).lower().replace(" ", "_").replace("-", "_")

    parser = argparse.ArgumentParser(
        prog=prog_name,
        description="A python tool for auto-generating or auto-updating usage of python cli tools.",
    )
    parser.add_argument(
        "-V", "--version", action="version", version=f"%(prog)s {__version__}"
    )
    parser.add_argument(
        "-c",
        "--command",
        help=f'main command, default is "python -m {prog_slug}"',
        default=f"python -m {prog_slug}",
    )

    subparser = parser.add_subparsers(title="Commands", metavar="<command>")
    quickstart_cmd = subparser.add_parser(
        "quickstart", help="quickstart for auto-usage."
    )
    quickstart_cmd.set_defaults(func=quickstart)
    args = parser.parse_args()
    if hasattr(args, "func"):
        args.func(args)
        sys.exit(0)

    readme = os.path.join(root, "README.md")
    try:
        usage = get_md_usage(args.command.split(" "))
    except Exception as e:
        raise RuntimeError("please use correct command.")

    print('"README.md" will be updated')

    with ReadmeEditor(readme, usage) as editor:
        editor.edit()

    print("Everything is OK.")


if __name__ == "__main__":
    main()
